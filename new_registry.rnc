
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"


##Primary structural elements
div
{
    start = reg.root-element
    
    reg.root-element =
        reg.registry
    
    reg.registry =
        ##Base element. Contains all of the information for Vulkan.
        element registry { reg.registry.contents }
       
    reg.registry.contents =
        reg.registry.attlist,
        reg.notation?,
        reg.vendorids?,
        reg.tags?,
        reg.definitions,
        reg.constants?,
        reg.enumerations?,
        reg.commands,
        reg.features,
        reg.extensions?
    
    reg.vendorids =
        ## The list of all vendorid elements.
        element vendorids { reg.vendorids.contents }
        
    reg.vendorids.contents =
        reg.vendorids.attlist,
        reg.vendorid+
        
    reg.vendorid =
        ## List of identifiers for vendors.
        element vendorid { reg.vendorid.contents }
    
    reg.vendorid.contents =
        reg.vendorid.attlist
        
    reg.tags =
        ## List of authors
        element tags { reg.tags.contents }
        
    reg.tags.contents =
        reg.tags.attlist,
        reg.tag+
        
    reg.tag =
        ## A single author for Vulkan
        element tag { reg.tag.contents }
        
    reg.tag.contents =
        reg.tag.attlist
        
    reg.definitions =
        ## List of all definitions used by Vulkan 
        element definitions { reg.definitions.contents }
        
    reg.definitions.contents =
        reg.definitions.attlist,
        reg.definitions.model+

    reg.definitions.model =
        reg.include | 
        reg.typedef | ## Formerly `basetype`
        reg.reference |   ## Formerly no category. Simply defines the existence of a named type that
                      ## usually is brought in by a `requires` attribute.
        reg.bitmask |
        
        reg.struct |
        reg.union |
        reg.define |
        reg.handle |
        reg.def.enumeration |
        reg.funcptr
    
    reg.constants =
        element constants {INCOMPLETE}
    
    reg.enumerations =
        element enumerations {INCOMPLETE}
        
    reg.commands =
        element commands {INCOMPLETE}
        
    reg.features =
        element features {INCOMPLETE}
        
    reg.extensions =
        element extensions {INCOMPLETE}
        
    reg.comment =
        ## Specifies a possibly multi-line in-language comment which is expected to be
        ## placed near the element in which `comment` appears.
        element comment {INCOMPLETE}
}

## Definition elements.
div
{
    reg.include =
        ## Definition that represents a file being included, which is named.
        ## The `name` attribute does double-duty, in that it also includes text.
        element include { reg.include.contents }
        
    reg.include.contents =
        reg.include.attlist
        
    reg.typedef =
        ## Definition that defines a new name for an existing type. 
        element typedef { reg.typedef.contents }
        
    reg.typedef.contents =
        reg.typedef.attlist
        
    reg.reference =
        ## Definition that references a type that comes from an include file.
        element reference { reg.reference.contents }
    
    reg.reference.contents =
        reg.reference.attlist
        
    reg.bitmask =
        ## Definition that specifies a bitmask, using a particular existing type.
        ## Contents are the same as `typedef`.
        element bitmask { reg.bitmask.contents }
        
    reg.bitmask.contents =
        ## Uses the same structure and meaning as typedefs.
        reg.typedef.attlist
    
    reg.define =
        ## Definition that represents a C #define statement.
        element define { reg.define.contents }
        
    ## The 3 forms of definitions:
    ## #define name C-expression
    ## #define name(params) C-expression
    ## C-expression
    ##
    ## In all cases, C-expression should be verbatim copied. The question is whether it includes
    ## the actual C-langauge #define or not.
    ## Defines can also reference other definitions.    
    reg.define.contents =
        reg.define.attlist,
        reg.comment?,
        reg.define.model
        
    reg.define.model = 
        (reg.define.value.attrib | reg.define.complex.model)

    reg.define.complex.model =
        (reg.define.replace.attrib?, reg.define.defref*, reg.define.param*, reg.c-expression)
    
    reg.define.defref =
        ## Specifies a definition that this #define references in its C-expression.
        element defref { reg.identifier.data }
        
    reg.define.param =
        ## The name of a #define's parameter.
        element param { reg.identifier.data }
    
    reg.c-expression =
        ## Text that is intended to be used verbatim in C or C++ implementations.
        ## If the `replace` attribute is not `true`, then the processor should
        ## generate the `#define NAME(PARAMS)` part of the define, before the c-expression.
        element c-expression { text }
        
    reg.handle =
        ## Creates a definition for a handle.
        element handle { reg.handle.contents }
        
    reg.handle.contents =
        reg.handle.attlist

    reg.def.enumeration =
        element enumeration { reg.def.enumeration.contents }
        
    reg.def.enumeration.contents =
        reg.def.enumeration.attlist
        
    reg.struct =
        ## Definition that represents a data structure.
        ## Contains a list of members and optional validation information.
        element struct { reg.struct.contents }
    
    reg.struct.contents =
        reg.struct.attlist,
        reg.struct.member+,
        reg.validity?
        
    reg.struct.member =
        ## Specifies a named member of a data structure.
        element member { reg.struct.member.contents }
    
    reg.struct.member.contents =
        reg.struct.member.attlist

    reg.validity =
        ## Defines validation text related to objects and commands.
        element validity { reg.validity.contents }
        
    reg.validity.contents =
        reg.validity.usage+
    
    reg.validity.usage =
        ## A specific validation rule, spelled out in documentation text.
        element usage { reg.validity.usage.contents }
        
    reg.validity.usage.contents =
        ## Required to be documentation text.
        text

    reg.union =
        ## Defines a union, where the object's value is only one of the members.
        element union { reg.union.contents }
        
    reg.union.contents =
        reg.union.attlist,
        reg.union.member+

    reg.union.member =
        ## Specifies a named member of a union.
        element member { reg.union.member.contents }
        
    reg.union.member.contents =
        reg.union.member.attlist
    
    reg.funcptr =
        ## Defines a function pointer.
        element funcptr { reg.funcptr.contents }
        
    reg.funcptr.contents =
        reg.funcptr.attlist,
        reg.return-type,
        reg.param*

    reg.return-type =
        element return-type { reg.return-type.contents }
        
    reg.return-type.contents =
        reg.return-type.attlist

    reg.param =
        element param { reg.param.contents }
    
    reg.param.contents =
        reg.param.attlist
}

## Supplementary elements and definitions.
div
{
    reg.notation =
        ##A textual annotation regarding a particular element.
        element notation { text }
    
    INCOMPLETE = empty
}


## Attribute definitions
div
{
    reg.notation.attrib =
        ##A textual notation regarding a particular element 
        attribute notation { text }
    
    reg.any.name.attrib =
        ## String name for an element.
        attribute name { text }
        
    reg.api.name.attrib =
        ## String name for a definition that is part of the Vulkan API.
        ## It *must* be a valid C/C++ identifier.
        attribute name { reg.identifier.data }

    reg.registry.attlist = empty
    
    reg.vendorids.attlist = empty
    
    reg.vendorid.attlist =
        reg.any.name.attrib,
        reg.vendorid.id.attrib,
        reg.notation.attrib?
        
    reg.vendorid.id.attrib =
        ## Hexadecimal integer identifier for a vendor.
        attribute id { text }
        
    reg.tags.attlist = empty
    
    reg.tag.attlist =
        reg.any.name.attrib,
        reg.tag.author.attrib,
        reg.tag.contact.attrib,
        reg.notation.attrib?
        
    reg.tag.author.attrib =
        ## Author name, usually a company or project
        attribute author { text }
        
    reg.tag.contact.attrib =
        ## Name and contact information for the person responsible for the tag
        attribute contact { text }
        
    reg.definitions.attlist =
        empty
        
    reg.definition.common.model =
        ## Attributes common to all definitions.
        reg.api.name.attrib,
        reg.notation.attrib?
    
    reg.include.attlist =
        ## Include's `name` is a full pathname, not just an identifier.
        reg.any.name.attrib,
        reg.notation.attrib?,
        reg.include.style.attrib,
        reg.include.need-ext.attrib?
        
    reg.include.style.attrib =
        ## Specifies whether to use "" or <> around the include name.
        attribute style { "quote" | "bracket" }
        
    reg.include.need-ext.attrib =
        ## This specifies whether the processor needs to append a `.h` extension to the include name.
        ## This is only necessary for the special case of `vk_platform`, because the `.h` is
        ## not included in the name. In all other cases, it is.
        [ a:default-value = "false" ]
        attribute need-ext { reg.boolean.data }
        
    reg.typedef.attlist =
        reg.definition.common.model,
        reg.typedef.base-type.attrib
        
    reg.typedef.base-type.attrib =
        ## Specifies the original typename for the typedef.
        ## This name should reference an existing definition.
        attribute base-type { reg.identifier.data }
        
    reg.reference.attlist =
        reg.definition.common.model,
        reg.reference.include.attrib
        
    reg.reference.include.attrib =
        ## Specifies the include file that produces the name.
        ## This text should specify the name of an existing definition of
        ## type `include`.
        attribute include { text }
        
    reg.define.attlist =
        reg.definition.common.model,
        reg.define.disabled.attrib
        
    reg.define.disabled.attrib =
        ## If "true", then the processor should generate the #define in a comment.
        ## That is, the #define exists, but has been commented out for some reason.
        [ a:default-value = "false" ]
        attribute disabled { reg.boolean.data }
    
    reg.define.replace.attrib =
        ## If "true", then the processor should not attempt to generate the #define
        ## statement at all. The entire c-expression will include the #define
        ## as well as the typename of the define.
        ## It is useful for very complex #defines.
        [ a:default-value = "false" ]
        attribute replace { reg.boolean.data }
        
    reg.define.value.attrib =
        ## A #define's value which represents something that is generally language neutral.
        ## A decimal number or string literal, for example.
        attribute value { text }

    reg.handle.attlist =
        reg.definition.common.model,
        reg.handle.type.attrib

    reg.handle.type.attrib =
        ## Whether the handle is dispatchable or not.
        attribute type { "dispatch" | "nodispatch" }

    reg.def.enumeration.attlist =
        reg.definition.common.model
    
    reg.struct.attlist =
        reg.definition.common.model,
        reg.struct.is-return.attrib?
        
    reg.struct.is-return.attrib =
        ## When set to `true`, the struct is used only as a return value by the Vulkan API.
        [a:default-value = "false"]
        attribute is-return { reg.boolean.data }
        
    reg.struct.member.attlist =
        reg.definition.common.model,
        reg.variable.definition.model,
        reg.variable.meta-data.model
    
    reg.variable.definition.model =
        ## The attributes which describe how the variable should be defined.
        reg.variable.basetype.attrib,
        reg.variable.array.model?,
        reg.variable.const.attrib?,
        reg.variable.reference.attrib?
        
    reg.variable.array.model =
        ((reg.variable.static.array.attrib, reg.variable.static.array.size.attrib) |
        (reg.variable.dynamic.array.attrib, reg.variable.dynamic.array.size.attrib?,
        reg.variable.dynamic.array.null-terminate.attrib?))
    
    reg.variable.meta-data.model =
        ## Information about how the variable will be treated by the API.
        reg.variable.optional.attrib?,
        reg.variable.auto-validity.attrib?,
        reg.variable.inout.attrib?,
        reg.variable.sync.attrib?
    
    reg.variable.basetype.attrib =
        ## The fundamental typename of the variable. This names a definition.
        attribute basetype { reg.identifier.data }

    reg.variable.const.attrib =
        ## If `true`, then the variable's base type is constant. If the type is
        ## a pointer or array, the `const` refers to the base type. So `const T *` rather
        ## than `T *const`.
        [a:default-value = "false"]
        attribute const { reg.boolean.data }
    
    reg.variable.reference.attrib =
        ## If present, then the variable is a pointer of some sort.
        ## This does not guarantee that variable is an *array*.
        attribute reference {
            ## Type is a pointer
            "pointer" |
             ## Type is a pointer-to-a-pointer, perhaps a dynamic array of pointers
            "pointer-pointer" |
            ## Type is a `* const *`. A dynamic array of const pointers to (possibly const) base-type.
            "pointer-const-pointer"
        }

    reg.variable.static.array.attrib =
        ## The variable is a compile-time sized array.
        attribute array { "static" }

    reg.variable.static.array.size.attrib =
        ## The length of a static array variable, specified as an integer literal or an
        ## identifier that references a `constant`.
        ## Must be present on all static arrays.
        attribute size { xsd:positiveInteger | reg.identifier.data }

    reg.variable.dynamic.array.attrib =
        ## The variable is a runtime sized array.
        attribute array { "dynamic" }

    reg.variable.dynamic.array.size.attrib =
        ## The name of a construct (usually a member of the same struct or parameter to the same
        ## function that provides the size of a dynamic array.
        ## Optional.
        attribute size { reg.identifier.data }
        
    reg.variable.dynamic.array.null-terminate.attrib =
        ## If `true`, then a `dynamic` array string variable is null-terminated.
        [a:default-value = "false"]
        attribute null-terminate { reg.boolean.data }

    reg.variable.optional.attrib =
        ## If set to "true", then the variable may be a null-pointer or zero, depending on the type.
        [a:default-value = "false"]
        attribute optional { reg.boolean.data }

    reg.variable.auto-validity.attrib =
        ## If set to "false", then auto-validation for the variable should not be generated.
        [a:default-value = "true"]
        attribute auto-validity { reg.boolean.data }
    
    reg.variable.sync.attrib =
        ## If set to "external", then the user must externally synchronize access to the
        ## object the variable stores.
        [a:default-value = "none"]
        attribute sync { "external" | "none" }
        
    reg.variable.inout.attrib =
        ## Determines whether the variable is used as an input, output, or both.
        [a:default-value = "in"]
        attribute inout { "in" | "out" | "inout" }
    
    reg.union.attlist =
        reg.definition.common.model
    
    reg.union.member.attlist =
        reg.definition.common.model,
        reg.variable.definition.model

    reg.funcptr.attlist =
        reg.definition.common.model

    reg.return-type.attlist =
        reg.definition.common.model,
        reg.variable.definition.model

    reg.param.attlist =
        reg.definition.common.model,
        reg.variable.definition.model,
        reg.variable.meta-data.model
}

## Data types
div
{
    ## Should be a valid C/C++ identifier.
    reg.identifier.data = text
    
    ## Recognize a hexadecimal number.
    reg.hexadecimal.data = text
    
    reg.boolean.data = xsd:boolean
}